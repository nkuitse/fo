#!/usr/bin/perl

use strict;
use warnings;

use File::Basename qw(basename dirname);
use File::Copy qw(copy move);
use Data::Floid;
use Graphics::Magick qw();
use Image::ExifTool qw();
use POSIX qw(strftime);
use Digest;
use Text::ParseWords qw(shellwords);
use DBI;
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

use constant MINDATE => '19700101';
# use constant DEBUG => 0;

# *move = *copy if DEBUG;

sub usage;
sub fatal;

my %dir;
my %key2code = qw(
    created  C
    imported I
    file     F
    rotate   R
);
my %code2key = reverse %key2code;
my %config = (
    'preview-size' => [480, 480],
    'root' => ($ENV{'PHOTOS'} || glob('~/photos')),
    'viewer' => 'sxiv',
);

usage if !@ARGV;

my $dbfile = 'db/photos.sqlite3';
my ($dbh, %sth);
my $digest = Digest->new('MD5');

init();
run_command();

# --- Command handlers

sub cmd_view {
    my ($view_master);
    GetOptions(
        'm|master' => \$view_master,
    ) or usage;
    usage if !@ARGV;
    my $db = db('r');
    my @cmd = shellwords($config{'viewer'});
    my ($previews, $masters);
    foreach my $fid (@ARGV) {
        if ($view_master) {
            $masters ||= read_master_list();
            my $md5 = $masters->{$fid};
            fatal "no such photo: $fid" if !defined $md5;
            push @cmd, master($md5);
        }
        else {
            $previews ||= read_preview_list();
            my $preview = $previews->{$fid}
                or fatal "no preview for $fid";
            push @cmd, $preview;
        }
    }
    system(@cmd) == 0 or fatal "$cmd[0] failed: $!";
}

sub cmd_check {
    @ARGV = grep { /\.jpg$/i && -f } glob('source/*/import/*')
        if !@ARGV;
    my $db = db('rw');
    my $err = 0;
    my $md5s;
    foreach my $f (@ARGV) {
        # Check to see if it's already been imported
        my $md5 = md5($f);
        my $fid = eval { $db->uget($md5) };
        my $master = master($md5);
        if (defined $fid) {
            print STDERR "+ $fid $f\n";
            $err++;
        }
        elsif (-e $master) {
            if (!$md5s) {
                $md5s = { reverse read_master_list() };
            }
            $fid = $md5s->{$md5};
            if (defined $fid) {
                eval { $db->uset($md5, $fid) };
                print STDERR "* $fid $f\n";
            }
            else {
                print STDERR "E $f : master $master not in masters.list\n";
            }
            $err++;
        }
        else {
            print STDERR "- $f\n";
        }
    }
    exit $err ? 2 : 0;
}

sub cmd_import {
    @ARGV = grep { /\.jpg$/i && -f } glob('source/*/import/*')
        if !@ARGV;
    if (!@ARGV) {
        print STDERR "nothing to import\n";
        exit 0;
    }
    my $db = db('rw');
    my $exif = exif();
    my $today = strftime('%Y%m%d', localtime);
    open my $log, '>>', mkfile('log', 'import.log')
        or die "Can't open import log: $!";
    open my $list, '>>', 'masters.list'
        or die "Can't open masters.list: $!";
    open my $thlist, '>>', 'preview.list'
        or die "Can't open preview list: $!";
    foreach my $f (@ARGV) {
        # Check to see if it's already been imported
        my $md5 = md5($f);
        my $fid = eval { $db->get($md5) };
        if (defined $fid) {
            print STDERR "- $fid $md5 $f :: already present\n";
            next;
        }
        # Get the photo ID and record the MD5 hash
        $exif->ExtractInfo($f);
        my $rot = exif_rotate($exif);
        my ($date, $y, $m, $d, $H, $M, $S) = exif_date($exif);
        my $ymd = $y.$m.$d;
        $fid = $db->mint('%N5d', mkmeta(
            'created' => $ymd,
            'imported' => $today,
            'file' => $f,
            'rotate' => $rot,
        ));
        $db->uset($md5 => $fid);
        # Write the master
        my $master = mkfile('masters', prefix($md5), "$md5.jpg");
        mkcopy($f, $master, 0444);
        print $list "$fid $md5\n";
        my $magick = magick($master);
        my ($w, $h) = $magick->Get(qw(width height));
        # Write the derived preview
        my $dst = mkpreview($y, $m, $d, $fid);
        create_preview(
            $master,
            $dst,
            'fid' => $fid,
            'rotate' => $rot,
            'master' => $md5,
            'magick' => $magick,
        );
        print $list "$fid $dst\n";
        # Add to DB
        insert(
            'id' => $fid,
            'md5' => $md5,
            'taken' => $date,
            'width' => $w,
            'height' => $h,
            'rotate' => $rot,
        );
        # Log it
        print $log "$today $fid $md5 $f\n";
        print STDERR "+ $fid $md5 $y $m $d $f\n";
    }
}

sub cmd_preview {
    my ($force, $check, $verbose, $rotation);
    GetOptions(
        'f|force' => \$force,
        'k|check' => \$check,
        'v|verbose' => \$verbose,
        'r|rotation=s' => \$rotation,
    ) or usage;
    usage if $check && $force;
    my $exif = exif();
    my $db = db('r');
    my $previews = read_preview_list();
    my $masters = read_master_list();
    my $list;
    foreach my $fid (@ARGV) {
        my $md5 = $masters->{$fid};
        if (!defined $md5) {
            print STDERR "E $fid : unknown fid\n";
            next;
        }
        my $preview = $previews->{$fid};
        if ($preview && -e $preview && !$force) {
            if ($check) {
                print $fid, ' ' if $verbose;
                print $preview, "\n";
                $check++;
            }
            else {
                print STDERR "- $fid : preview already exists\n";
            }
            next;
        }
        my $src = master($md5);
        if (!-e $src) {
            print STDERR "E $fid : no master\n";
            next;
        }
        $exif->ExtractInfo($src);
        my ($date, $y, $m, $d) = exif_date($exif);
        my $rot = $rotation || exif_rotate($exif) || 0;
        my ($pw, $ph) = @{ $config{'preview-size'} };
        ($pw, $ph) = ($ph, $pw) if abs($rot) == 90;
        my $dst = mkpreview($y, $m, $d, $fid);
        if ($preview && $preview ne $dst && -e $preview) {
            unlink $preview;
            print STDERR "D $fid $preview\n";
        }
        if (-e $dst) {
            if (!$force) {
                print STDERR "- $fid $dst\n";
                next;
            }
            print STDERR "* $fid $dst\n";
        }
        create_preview(
            $src,
            $dst,
            'fid' => $fid,
            'rotate' => $rot,
            'master' => $md5,
        );
        if (!$list) {
            open $list, '>>', 'preview.list'
                or fatal "open preview.list: $!";
        }
        print $list "$fid $dst\n";
        print STDERR "+ $fid $dst\n" if $verbose;
    }
    if ($check) {
        exit 0 if $check > @ARGV;
        fatal "some not found" if $verbose;
        exit 2;
    }
}

sub cmd_render {
    my ($size, $rotation);
    GetOptions(
        's|size=s' => \$size,
        'r|rotation=s' => \$rotation,
    ) or usage;
    $size = size($size);
    my ($pw, $ph);
    die "Not yet implemented";
    usage if !@ARGV;
    expand(@ARGV);
    foreach my $fid (@ARGV) {
        my $master = master($fid);
        my $magick = magick($master);
        render($magick, mkfile('derived', $size, prefix($fid)),
            'strip' => 1,
            'width' => $pw,
            'height' => $ph,
            'rotate' => $rotation,
        );
    }
}

sub cmd_tail {
    my $sth = sth('tail', <<'EOS');
SELECT id FROM photos ORDER BY id DESC LIMIT ?
EOS
    my $n = @ARGV ? shift @ARGV : 10;
    $sth->execute($n) or fatal $sth->errstr;
    my @tail;
    while (my ($id) = $sth->fetchrow_array) {
        unshift @tail, $id;
    }
    print fid($_), "\n" for @tail;
}

# --- Other functions

sub fid { sprintf '%05d', shift }

sub mkpreview {
    my ($y, $m, $d, $fid) = @_;
    return mkfile('preview', "$y-$m", "$d-$fid.jpg"),
}

sub create_preview {
    my ($src, $dst, %arg) = @_;
    my ($pw, $ph) = @{ $config{'preview-size'} };
    my $rot = $arg{'rotate'} || 0;
    ($pw, $ph) = ($ph, $pw) if abs($rot) == 90;
    my $magick = $arg{'magick'} || magick($src);
    # my ($w, $h) = $magick->Get('width', 'height');
    render($magick, $dst,
        'strip' => 1,
        'width' => $pw,
        'height' => $ph,
        %arg,
    );
}

sub prefix { substr(shift, 0, 2) }

sub master {
    my ($fid) = @_;
    my $pfx = prefix($fid);
    return "masters/$pfx/$fid.jpg";
}

sub mkmeta {
    my %meta = @_;
    return join("\n", map { join(':', $key2code{$_}, $meta{$_}) } sort keys %meta);
}

sub render {
    my ($magick, $f, %arg) = @_;
    my $geom;
    $geom = join('x', @arg{qw(width height)}) if defined $arg{'width'} && defined $arg{'height'};
    $magick->Profile if $arg{'strip'};
    $magick->Rotate('degrees' => $arg{'rotate'}) if $arg{'rotate'};
    $magick->Scale('geometry' => $geom) if defined $geom;
    $magick->Write($f);
}

sub init {
    read_config();
    use_plugins();
    fatal "can't determine root" if !defined $config{root};
    chdir($config{root}) or fatal "chdir $config{root}: $!";
    open_sqlite3_db();
}

sub open_sqlite3_db {
    $dbh = DBI->connect(sprintf('dbi:SQLite:dbname=%s', $dbfile), '', '');
}

sub sth {
    my ($key, $sql) = @_;
    return $sth{$key} ||= $dbh->prepare($sql);
}

sub db {
    my ($mode) = @_;
    return Data::Floid->new(
        'dbm' => 'DB_File',
        'path' => 'db/photos.db',
        'mode' => $mode,
    );
}

sub insert {
    my ($photo) = @_;
    my $sth = sth('insert', <<'EOS');
INSERT OR REPLACE
INTO photos
        ( id, md5, taken, width, height, rotate )
VALUES  ( ?,  ?,   ?,     ?,     ?,      ?      )
EOS
    $sth->execute(@$photo{qw(id md5 taken width height rotate)});
}

sub run_command {
    &{ __PACKAGE__->can('cmd_' . shift @ARGV) or usage };
}

sub mkfile {
    my $name = pop;
    mkpath(@_) . '/' . $name;
}

sub mkpath {
    my $path = shift;
    my @paths = ( $path );
    foreach (@_) {
        push @paths, $path .= '/' . $_;
    }
    foreach my $d (@paths) {
        $dir{$d}++
            or -d $d
            or mkdir $d
            or die "Can't mkdir $d: $!";
    }
    pop @paths;
}

sub mkcopy {
    my ($fa, $fb, $mode) = @_;
    move($fa, $fb) or copy($fa, $fb) or die "Can't copy $fa to $fb: $!";
    chmod($mode, $fb) if defined $mode;
    return $fb;
}

sub md5 {
    my ($f) = @_;
    open my $fh, '<', $f or die "Can't open file $f for reading: $!";
    $digest->addfile($fh);
    return $digest->hexdigest;
}

sub exif {
    my $exif = Image::ExifTool->new;
    $exif->Options('DateFormat' => '%Y%m%dT%H%M%S', 'StrictDate' => 1);
    return $exif;
}

sub magick {
    my ($f) = @_;
    my $magick = Graphics::Magick->new;
    $magick->Read($f);
    return $magick;
}

sub exif_rotate {
    my ($exif) = @_;
    my $orient = $exif->GetValue('Orientation', 'ValueConv');
    $exif->SetNewValue('Orientation#' => 1)
        if !defined $orient || $orient != 1;
    return if !defined $orient;
    return +90 if $orient == 6;
    return -90 if $orient == 8;
    return 180 if $orient == 3;
    return 0;
}

sub exif_date {
    my ($exif) = @_;
    my ($date, @date) = qw(19700101T000000 1970 01 01 00 00 00);
    foreach (qw(CreateDate DateTimeOriginal FileModifyDate)) {
        my $rawdate = $exif->GetValue($_) or next;
        if ($rawdate =~ /^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/ && $1 gt '1970') {
            ($date, @date) = ($rawdate, $1, $2, $3, $4, $5, $6);
            last;
        }
    }
    return wantarray ? ($date, @date) : $date;
}

sub use_plugins {
    foreach my $f (grep { -x && -f _ } glob('lib/f5*.pl')) {
        if (!do $f) {
            my $err = $@ || $! || 'false return value';
            die "Can't use plugin $_: $err\n";
        }
    }
}

sub read_config {
    my ($config_file) = map { glob($_) } qw(~/etc/fo/fo.conf ~/.config/fo/fo.conf ~/.forc);
    return if !defined $config_file || !-e $config_file;
    open my $fh, '<', $config_file or fatal "open $config_file: $!";
    while (<$fh>) {
        next if /^\s*(#.*)?$/;  # Skip blank lines and comments
        $config{$1} = $2, next if /^\s*(\S+)\s+(.*)$/;
        chomp;
        fatal "unrecognized config setting in $config_file: $_";
    }
}

sub read_master_list {
    open my $list, '<', 'masters.list'
        or fatal "open masters.list: $!";
    my %photo;
    while (<$list>) {
        my ($fid, $md5) = ( /^(\d+) (\S+)/ );
        $photo{$fid} = $md5;
    }
    close $list;
    return \%photo;
}

sub read_preview_list {
    open my $log, '<', 'preview.list'
        or fatal "open preview.list: $!";
    my %preview;
    while (<$log>) {
        my ($fid, $file) = ( /^(\d+) (\S+)/ );
        $preview{$fid} = $file;
    }
    close $log;
    return \%preview;
}

sub init_sql {
}
